package com.battleship.core.service.game;

import java.util.Random;

import com.battleship.core.model.attack.AttackResult;
import com.battleship.core.model.attack.AttackType;
import com.battleship.core.model.board.Board;
import com.battleship.core.model.board.Position;
import com.battleship.core.model.game.GameMode;
import com.battleship.core.model.game.GameState;
import com.battleship.core.model.player.Player;
import com.battleship.core.service.attack.IAttackService;
import com.battleship.core.service.board.IBoardService;
import com.battleship.core.service.player.IBotService;
import com.battleship.core.service.player.IPlayerService;
import com.battleship.data.DataConstants;

public class GameServiceImpl implements IGameService {
	private final IPlayerService playerService;
    private final IBoardService boardService1;
    private final IBoardService boardService2;
    private final IAttackService attackService;
    private final IGameStateService stateService;
    private final IBotService botService;
    private final Random random;
    private GameMode gameMode;
    private GameState currentState;

    public GameServiceImpl(
        IPlayerService playerService,
        IBoardService boardService1,
        IBoardService boardService2,
        IAttackService attackService,
        IGameStateService stateService,
        IBotService botService
    ) {
        this.playerService = playerService;
        this.boardService1 = boardService1;
        this.boardService2 = boardService2;
        this.attackService = attackService;
        this.stateService = stateService;
        this.botService = botService;
        this.random = new Random();
        this.currentState = GameState.NOT_STARTED;
    }

    @Override
    public void initializeGame(GameMode gameMode) {
        this.gameMode = gameMode;
        this.currentState = GameState.INITIALIZING;
        stateService.setState(GameState.INITIALIZING);
        
        // Reset boards
        boardService1.resetBoard();
        boardService2.resetBoard();
        
        // Xử lý theo từng chế độ
        if (gameMode == GameMode.VS_BOT) {
            initializeVsBotMode();
        } else if (gameMode == GameMode.CHALLENGE) {
            initializeChallengeMode();
        }
        
        this.currentState = GameState.READY;
        stateService.setState(GameState.READY);
    }

    private void initializeVsBotMode() {
        // Load bàn cờ cho bot từ thư mục vsbot
        String botBoardPath = DataConstants.VSBOT_DIR + "/" + 
                            String.format(DataConstants.BOT_BOARD_PATTERN, 1);
        if (!botService.loadBoard(botBoardPath)) {
            throw new IllegalStateException("Failed to load bot board");
        }

        // Set board cho player 2 (bot)
        Player bot = getOpponentPlayer();
        bot.setBoard(botService.getBoard());

        // Khởi tạo inventory cho người chơi với tấn công đơn lẻ
        Player player1 = getCurrentPlayer();
        player1.getInventory().initializeVsBotMode();
    }

    private void initializeChallengeMode() {
        // Load ngẫu nhiên một bàn cờ từ thư mục challenge
        int randomLevel = random.nextInt(5) + 1; // Giả sử có 5 level
        String challengeBoardPath = DataConstants.CHALLENGE_DIR + "/" + 
                                  String.format(DataConstants.CHALLENGE_BOARD_PATTERN, randomLevel);
        if (!boardService2.loadBoard(challengeBoardPath)) {
            throw new IllegalStateException("Failed to load challenge board");
        }

        // Khởi tạo inventory cho người chơi với các loại tấn công
        Player player1 = getCurrentPlayer();
        player1.getInventory().initializeChallengeMode();
    }

    @Override
    public void startGame() {
        if (currentState != GameState.READY) {
            throw new IllegalStateException("Game is not ready to start");
        }
        currentState = GameState.PLAYING;
        stateService.setState(GameState.PLAYING);
    }

    @Override
    public void endGame() {
        currentState = GameState.FINISHED;
        stateService.setState(GameState.FINISHED);
    }

    @Override
    public void pauseGame() {
        if (currentState == GameState.PLAYING) {
            currentState = GameState.PAUSED;
            stateService.setState(GameState.PAUSED);
        }
    }

    @Override
    public void resumeGame() {
        if (currentState == GameState.PAUSED) {
            currentState = GameState.PLAYING;
            stateService.setState(GameState.PLAYING);
        }
    }

    @Override
    public GameState getCurrentState() {
        return currentState;
    }

    @Override
    public boolean isGameOver() {
        return currentState == GameState.FINISHED;
    }

    @Override
    public Player getCurrentPlayer() {
        return playerService.getCurrentPlayer();
    }

    @Override
    public Player getOpponentPlayer() {
        return playerService.getOpponentPlayer();
    }

    @Override
    public GameMode getGameMode() {
        return gameMode;
    }

    /**
     * Thực hiện lượt tấn công
     * @param position Vị trí tấn công
     * @return true nếu lượt tấn công thành công
     */
    public boolean performAttack(Position position) {
        if (currentState != GameState.PLAYING) {
            return false;
        }

        Player currentPlayer = getCurrentPlayer();
        Player opponent = getOpponentPlayer();
        Board targetBoard = (Board) opponent.getBoard();

        // Kiểm tra vị trí tấn công hợp lệ
        if (!attackService.isValidAttack(position, targetBoard)) {
            return false;
        }

        // Kiểm tra loại tấn công dựa trên chế độ
        if (gameMode == GameMode.VS_BOT) {
            if (currentPlayer.getInventory().getCurrentAttackType() != AttackType.SINGLE) {
                return false;
            }
        }

        // Thực hiện tấn công
        AttackResult result = attackService.attack(position, currentPlayer, targetBoard);
        handleAttackResult(result, currentPlayer, opponent);

        return true;
    }

    /**
     * Xử lý kết quả tấn công
     * @param result Kết quả tấn công
     * @param attacker Người tấn công
     * @param defender Người phòng thủ
     */
    private void handleAttackResult(AttackResult result, Player attacker, Player defender) {
        // Xử lý kết quả tấn công
        if (result.isHit()) {
            if (result.isSunk()) {
                System.out.println("Ship sunk at position: " + result.getPosition());
                
                if (defender.isDefeated()) {
                    handleGameEnd(attacker);
                    return;
                }
            } else {
                System.out.println("Hit at position: " + result.getPosition());
            }
        } else {
            System.out.println("Miss at position: " + result.getPosition());
        }

        // Xử lý lượt chơi tiếp theo
        if (currentState == GameState.PLAYING) {
            if (gameMode == GameMode.VS_BOT && attacker == getCurrentPlayer()) {
                performBotAttack();
            } else {
                playerService.switchTurn();
            }
        }
    }
    
    private void handleGameEnd(Player winner) {
        System.out.println("Player " + winner.getName() + " wins!");
        
        if (gameMode == GameMode.CHALLENGE) {
            System.out.println("Challenge completed! You can play again or exit.");
        }
        
        endGame();
    }

    private void performBotAttack() {
        Player bot = getOpponentPlayer();
        Player human = getCurrentPlayer();
        Board targetBoard = (Board) human.getBoard();

        // Lấy vị trí tấn công từ bot
        Position attackPosition = botService.getAttackPositions(null, targetBoard).get(0);
        
        // Thực hiện tấn công
        AttackResult result = attackService.attack(attackPosition, bot, targetBoard);
        handleAttackResult(result, bot, human);
    }

    /**
     * Kiểm tra xem game có thể tiếp tục không
     * @return true nếu game có thể tiếp tục
     */
    public boolean canContinueGame() {
        return stateService.canContinueGame();
    }

    /**
     * Lưu trạng thái game hiện tại
     */
    public void saveGameState() {
        stateService.saveGameState();
    }

    /**
     * Tải trạng thái game đã lưu
     */
    public void loadGameState() {
        stateService.loadGameState();
        this.currentState = stateService.getCurrentState();
    }

}
